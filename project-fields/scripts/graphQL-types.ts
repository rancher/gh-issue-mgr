import * as fs from 'fs';
import * as path from 'path';

/** This map defines how each GraphQL type should be translated to TypeScript */
const paramTypes: Record<string, string> = {
  ID: 'string',
  String: 'string',
  Boolean: 'boolean',
  Int: 'number',
  Float: 'number',
  Date: 'any',
  URI: 'string',
  ProjectV2FieldValue: 'ProjectV2FieldValue',
};

function parseQuery(query: string) {
  const INFO_REGEX =
    /^(?<type>query|mutation)\s+(?<reqName>\w+)\s*\(\s*(?<paramDecl>[^{]*)\)/;
  const PARAM_REGEX = /^ *\$(?<name>\w+) *: *(?<type>\w+)(?<required>!?) *$/;

  const {type, reqName, paramDecl} = query.match(INFO_REGEX)?.groups ?? {};
  const params = paramDecl
    .trim()
    .split(/[,\n]/g)
    .map(param => {
      const {name, type, required} = param.match(PARAM_REGEX)?.groups ?? {};

      const parsedType = paramTypes[type];
      if (!parsedType) throw new Error(`Unknown type ${type} in ${reqName}`);

      return {name, type: paramTypes[type], required: !!required};
    });

  return {type, reqName, params};
}

(() => {
  const reqDirectories = ['../src/query', '../src/mutation'];

  const files = reqDirectories.flatMap(dir =>
    fs
      .readdirSync(path.join(__dirname, dir))
      .map(file => path.join(__dirname, dir, file))
  );

  const requests = files
    .map(file => fs.readFileSync(file, 'utf-8'))
    .map(parseQuery);

  console.log(JSON.stringify(requests, null, 2));

  const content = `
// This file is generated by scripts/generate-graphql-types.ts
// Do not edit this file directly

import * as ResponseTypes from './responseTypes';

export type Query = ${requests
    .filter(r => r.type === 'query')
    .map(r => `'${r.reqName}'`)
    .join(' | ')};
export type Mutation = ${requests
    .filter(r => r.type === 'mutation')
    .map(r => `'${r.reqName}'`)
    .join(' | ')};
export type Request = Query | Mutation;

export const supportedQueries = ${JSON.stringify(
    requests.filter(r => r.type === 'query').map(r => r.reqName),
    null,
    2
  )} as const
export const supportedMutations = ${JSON.stringify(
    requests.filter(r => r.type === 'mutation').map(r => r.reqName),
    null,
    2
  )} as const
export const supportedRequests = [...supportedQueries, ...supportedMutations];

export type ProjectV2FieldValue = 
  | { text: string }
  | { number: number }
  | { date: string }
  | { singleSelectOptionId: string }
  | { iterationId: string }

export type FieldDataType =
  | 'ASSIGNEES'
  | 'LINKED_PULL_REQUESTS'
  | 'REVIEWERS'
  | 'LABELS'
  | 'MILESTONE'
  | 'REPOSITORY'
  | 'TITLE'
  | 'TEXT'
  | 'SINGLE_SELECT'
  | 'NUMBER'
  | 'DATE'
  | 'ITERATION'
  | 'TRACKS'
  | 'TRACKED_BY';

export type RequestParams<T extends Request> = 
${requests
  .map(req =>
    `T extends '${req.reqName}' ? {
${req.params
  .map(p => `  "${p.name}${p.required ? '' : '?'}": ${p.type};`)
  .join('\n')}
} :`
      .split('\n')
      .map(l => '  ' + l)
      .join('\n')
  )
  .join('\n')} never

export type Response<T extends Request> =
${requests
  .map(req =>
    `T extends '${req.reqName}' ? ResponseTypes.${req.reqName} :`
      .split('\n')
      .map(l => '  ' + l)
      .join('\n')
  )
  .join('\n')} never
  `;

  fs.writeFileSync(
    path.join(__dirname, '../src/api/generated.ts'),
    content,
    'utf-8'
  );
})();
